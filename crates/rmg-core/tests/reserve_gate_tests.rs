#![allow(missing_docs)]
use rmg_core::{decode_motion_payload, make_node_id, make_type_id, NodeRecord};

#[test]
fn reserve_gate_aborts_second_on_port_conflict() {
    // Engine with a single entity; register the port rule; apply it twice on same scope in one tx.
    let mut engine = rmg_core::demo::ports::build_port_demo_engine();
    engine
        .register_rule(rmg_core::demo::ports::port_rule())
        .expect("register port rule");

    // Create an entity node under root that weâ€™ll target.
    let entity = make_node_id("reserve-entity");
    let entity_ty = make_type_id("entity");
    engine.insert_node(
        entity,
        NodeRecord {
            ty: entity_ty,
            payload: None,
        },
    );

    let tx = engine.begin();
    let _ = engine.apply(tx, rmg_core::demo::ports::PORT_RULE_NAME, &entity);
    let _ = engine.apply(tx, rmg_core::demo::ports::PORT_RULE_NAME, &entity);
    let _snap = engine.commit(tx).expect("commit");

    // Exactly one executor should have run: pos.x == 1.0
    let (pos, _vel) = engine
        .node(&entity)
        .unwrap()
        .payload
        .as_ref()
        .and_then(decode_motion_payload)
        .expect("payload present");
    assert!((pos[0] - 1.0).abs() < 1e-6, "expected exactly one reservation to succeed");
}
